<!-- alt 4, 4 best collapse -->
<html>
	<head>
		<meta name='description' content='This page is a jaVascript program that uses CanVas API to paint a Minimized DFA (Deterministic Finite Automaton) from a giVen regular expression. Internally it generates, in order, an alphabet releVant to the specified regular expression, a tree to calculate follovvposes, a DFA from the tree and lastly the minimized DFA.'/>
		<title>Regular Expression To Minimized DFA (Deterministic Finite Automaton) - A DFA Painter</title>
		<style>
			* { font: 20px Arial Unicode MS; letter-spacing: 2px; }
			input { border-radius: 4px; margin: 0.20% 0px; }
			span { color: red; font-weight: 900; }
			td, th { border: 1px solid black; text-align: center; padding: 4px; }
			th { font: bold 20px consolas; }
			table { border-collapse: collapse; }
			canvas { border: 0px solid black; }
			.anHr { border-top: 1px solid lightgrey; margin: 20px 0px; }
			#output .anHr:nth-of-type(2) { display: none; }
			.hideHelp { display: none; }
            .hideAna > .analysis { display: none; }
            .hideBut input[type=button] { display: none; }
			pre { font: 20px Lucida Console; letter-spacing: 2px; }
		</style>
	</head>
	<body>
        <div>
		<input style="display: none;" type="button" onclick='document.getElementById("help").classList.add("hideHelp"); document.getElementById("thanks").classList.toggle("hideHelp");' value="Thanks" accesskey="T" title="T"/>
		<input style="display: none;" type="button" onclick='document.getElementById("thanks").classList.add("hideHelp"); document.getElementById("help").classList.toggle("hideHelp");' value="Help" accesskey="H" title="H"/>
		<diV class="hideHelp" id="thanks">
			<br>
			My Thanks goes to,
			<br><br>
			&nbsp;&nbsp;&nbsp;&nbsp;Vipul Papodara [ In 7th sem, you taught me making DFA from a regex this vvay :) ]
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;CD Dragon Book - Aho, Lam, Sethi, Ullman [ From regex to Tree to DFA ]
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;Introduction to Languages and The Theory of Computation 4ed - John C. Martin [ Minimization ]
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;JaVaScript: The DefinitiVe Guide 6ed - DaVid Flanagan [ using CanVas API ]
			<br><br>
		</diV>
		<diV class="hideHelp" id="help">
			<br>
			VVant to see DFA of eVen-lengthed-binary strings <span>(</span>00<span>+</span>11<span>+</span>10<span>+</span>01<span>)*</span> ?
			<br><br>
			Then simply type in your regular expression in the text-field and hit Enter-key to see hovv its minimized DFA could look.
			<br><br>
			But; there can be tvvo cases, depending on vvhether your alphabet contains tokens of length more than one or not.
			<br><br>
			For clarification,
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;A language vvith the alphabet <span>{</span>a<span>,</span> b<span>,</span> c<span>,</span> d<span>}</span> and another vvith the alphabet <span>{</span>ab<span>,</span> cd<span>}</span> differs in that the first
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;has each token of length 1 in contrast to the second vvhich has some token that has length more than 1.
			<br><br>
			If your case happens to be the first one, just type in your regex and hit the Enter-key and it vvill do.
			<br><br>
			Othervvise there are buttons that vvill help you build your regex.
			<br><br>
			For example, if your alphabet is <span>{</span>i<span>,</span> am<span>,</span> graduate<span>,</span> iit-k<span>}</span> and the regex is like,
			<br><br>
			&nbsp;&nbsp;&nbsp;&nbsp;<span>(</span>i<span>&bull;</span>am<span>)+(</span>iit-k<span>&bull;</span>graduate<span>)*</span>
			<br><br>
			Click <span>(</span> button
			<br><br>
			Type in
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;i
			<br><br>
			Click <span>CONCAT</span> button
			<br><br>
			Type in
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;am
			<br><br>
			Click <span>)</span> button
			<br><br>
			Click <span>OR</span> button
			<br><br>
			Click <span>(</span> button
			<br><br>
			Type in
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;iit-k
			<br><br>
			Click <span>CONCAT</span> button
			<br><br>
			Type in
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;graduate
			<br><br>
			Click <span>*</span> button
			<br><br>
			Click <span>)</span> button
			<br><br>
			Hit Enter-key.
			<br><br>
			<diV class="anHr"></diV>
			<br>
			In aboVe example the parentheses used are redundant. If it vvas specified like,
			<br><br>
			&nbsp;&nbsp;&nbsp;&nbsp;i<span>&bull;</span>am<span>+</span>iit-k<span>&bull;</span>graduate<span>*</span>
			<br><br>
			it vvould haVe the same effect. Because the logic assumes that the OR-operator delimits sub-expressions.
			<br><br>
			<diV class="anHr"></diV>
			<br>
			The Colors of States indicate their types,
			<br><br>
			<table>
				<tr>
					<th>Color</th>
					<th>State Type</th>
				</tr>
				<tr>
					<td style="color: white; background-color: #201291;">OFFSPRING</td>
					<td>NORMAL states</td>
				</tr>
				<tr>
					<td style="color: white; background-color: green;">GREEN</td>
					<td>ACCEPTING states</td>
				</tr>
				<tr>
					<td style="color: white; background-color: black;">BLACK</td>
					<td>DEAD state</td>
				</tr>
			</table>
			<br><br>
			<diV class="anHr"></diV>
			<br>
			Each button has an access-key assigned to it that may come in handy if brovvser allovvs it.
			You may be able to use it in combination vvith the ALT key.
			<br><br>
			<table>
				<tr>
					<th>Key</th>
					<th>Button</th>
					<th>Use</th>
				</tr>
				<tr>
					<td>.</td>
					<td>CONCAT</td>
					<td>To concat a nevv sub-expression</td>
				</tr>
				<tr>
					<td>S</td>
					<td>*</td>
					<td>To apply kleene-star to current sub-expression</td>
				</tr>
				<tr>
					<td>P</td>
					<td>OR</td>
					<td>To apply OR operator betvven current and next sub-expressions</td>
				</tr>
				<tr>
					<td>O</td>
					<td>(</td>
					<td>To start inserting a nevv sub-expression (that has multiple sub-expressions)</td>
				</tr>
				<tr>
					<td>C</td>
					<td>)</td>
					<td>To terminate the current sub-expression</td>
				</tr>
				<tr>
					<td>N</td>
					<td>NULL</td>
					<td>To insert a NULL string</td>
				</tr>
				<tr>
					<td>R</td>
					<td>RESET</td>
					<td>To reset all calculations so as to start building regex again</td>
				</tr>
				<tr>
					<td>M</td>
					<td>PAINT</td>
					<td>To paint the minimized DFA</td>
				</tr>
				<tr>
					<td>Q</td>
					<td>shovv/hide dead</td>
					<td>To toggle displaying dead states</td>
				</tr>
			</table>
			<br><br>
			<diV class="anHr"></diV>
			<br>
			And yes, vvhat if you vvant to specify the "NULL-string" into the single letter regex ?
			<br><br>
			Take for instance,
			<br><br>
			&nbsp;&nbsp;&nbsp;&nbsp;0<span>+</span>1<span>+NULL</span>
			<br><br>
			In such case, use the period (".") to specify the "String of length Zero". Thus it becomes,
			<br><br>
			&nbsp;&nbsp;&nbsp;&nbsp;0<span>+</span>1<span>+.</span>
			<br><br>
			<diV class="anHr"></diV>
			<br>
			Alright. But vvhat if "dot" itself is a part of the alphabet in the single letter regex ?
			<br><br>
			For example, alphabet=<span>{</span>0<span>,</span> 1<span>,</span> 2<span>,</span> .<span>,</span> 9<span>}</span> and regex=20.12.1991
			<br><br>
			VVell, then you just haVe to follovv the tradition id est, escape the period.
			<br><br>
			Thus, regex=20<span>\</span>.12<span>\</span>.1991
			<br><br>
			This vvay you vvill be able to use <span>{</span>.<span>,</span> +<span>,</span> (<span>,</span> )<span>,</span> *<span>,</span> \<span>}</span> as tokens by escaping them.
			<br><br><br>
		</diV>
		</div>
		<input type='text' style='width: 100%;' id='tf' onkeyup='if (event.keyCode == 13) { if (la2flag == true)  begin(); else la1(); init(); } else if(event.keyCode == (20 + 7)) this.value = "";' _placeholder="VVhateVer V du in dis vvorld vvill be insignificant; but it is V imp dat V du it; bcoz, nobody else vvill." title=
'IF YOU NEED TO REMOVE YOUR CURRENT INPUT,
INSTEAD OF HITTING A BUNCH OF BACKSPACES,
JUST HIT THE ESC-KEY FOR ONCE.' placeholder="Type in a RegEx, say - a+b*cd, and hit Enter to see its minimal DFA .. '+' is Oring operator and '*' is any number of occurrences i.e., {0,} .."/>
		<div id='buttons' class='hideBut'>
            <input type='button' title='.' accesskey='.' onclick='dot();'   value='CONCAT' />
            <input type='button' title='S' accesskey='S' onclick='star();'  value='*' />
            <input type='button' title='P' accesskey='P' onclick='plus();'  value='OR' />
            <input type='button' title='O' accesskey='O' onclick='op();'    value='(' />
            <input type='button' title='C' accesskey='C' onclick='cp();'    value=')' />
            <input type='button' title='N' accesskey='N' onclick='ns();'    value='NULL' />
            <input type='button' title='R' accesskey='R' onclick='init();'  value='RESET' />
            <input type='button' title='M' accesskey='M' onclick='if (la2flag == true) begin(); else la1(); init();' value='PAINT' />
            <input type='button' title='Q' accesskey='Q' onclick='this.value = (hideDead = !hideDead) ? "shovv dead" : "hide dead"; tf.focus();' value='shovv dead' />
            <input type='button' title='A' accesskey='A' onclick='this.value = ( hideAna = !hideAna ) ? "shovv analysis" : "hide analysis"; tf.focus(); output.classList.toggle("hideAna");' value='shovv analysis' />
            <input type='button' title='B' accesskey='B' onclick='this.value = ( hideBut = !hideBut ) ? "shovv buttons" : "hide buttons"; tf.focus(); buttons.classList.toggle("hideBut");' value='shovv buttons' />
		</div>
		<div id='output' class='hideAna'>
			<div id='regex'></div>
			<br id='bottom' />
		</div>
		<script>
            var la2flag = false;
			var hideDead = true;
			var hideAna = true;
			var hideBut = true;
			var output_initial_text = output.innerHTML;
			var ref_kid = bottom;
			init();
			function dot() {
				la2flag = true;
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;") + "<span>&bull;</span>";
					tf.value = "";
				}
				tf.focus();
			}
			function star() {
				la2flag = true;
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;");
				}
				re_ia[re_ia.length] = -1;
				regex.innerHTML += "<span>*</span>";
				tf.value = "";
				tf.focus();
			}
			function plus() {
				la2flag = true;
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;");
				}
				re_ia[re_ia.length] = -2;
				regex.innerHTML += "<span>+</span>";
				tf.value = "";
				tf.focus();
			}
			function op() {
				la2flag = true;
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;");
				}
				re_ia[re_ia.length] = -3;
				regex.innerHTML += "<span>(</span>";
				tf.value = "";
				tf.focus();
			}
			function cp() {
				la2flag = true;
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;");
				}
				re_ia[re_ia.length] = -4;
				regex.innerHTML += "<span>)</span>";
				tf.value = "";
				tf.focus();
			}
			function ns() {
				la2flag = true;
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;");
				}
				nulls[nulls.length] = ln2rei.length;
				ln2rei[ln2rei.length] = re_ia.length;
				re_ia[re_ia.length] = -5;
				regex.innerHTML += "<span>NULL</span>";
				tf.value = "";
				tf.focus();
			}
			function begin() {
				if (tf.value.length > 0) {
					var i = 0;
					for (; i < tokens.length; ++i) if (tokens[i] === tf.value) break;
					if (i == tokens.length) tokens[i] = tf.value;
					if (ti2lns[i] === undefined) ti2lns[i] = [ln2rei.length];
					else ti2lns[i][ti2lns[i].length] = ln2rei.length;
					ln2rei[ln2rei.length] = re_ia.length;
					re_ia[re_ia.length] = i;
					regex.innerHTML += tf.value.replace(/&/g,"&"+"amp;").replace(/>/g,"&"+"gt;").replace(/</g,"&"+"lt;");
				}
				if (re_ia.length == 0) { accNothing(); tf.focus(); return; }
				ln2rei[ln2rei.length] = re_ia.length;
				re_ia[re_ia.length] = -6;
				regex.innerHTML += "<span>EoRE</span>";
				tf.value = "";
				tf.focus();
				init_tree();
				make_tree();
				discard_unnecessary_nodes();
				make_indexes_start_from_0();
				calc_follovvpos();
				make_dfa();
				min_dfa();
				dravv_dfa();
				tf.focus();
			}
			function init() {
				tokens = new Array();
				re_ia = new Array();
				ln2rei = new Array();
				ti2lns = new Array();
				nulls = new Array();
				regex.innerHTML = "";
				tf.focus();
			}
			function node(id) {
				this.id = id;
				this.k = -1; // kid index in its parent
				this.p = null; // parent
				this.c = new Array(); // children
				this.t = -3; //-1* -2+ -3. -4DISCARDED OTHERWISE letter_no
				this.push = function() {
					for (var i = 0; i < arguments.length; ++i) {
						arguments[i].k = this.c.length;
						(this.c[this.c.length] = arguments[i]).p = this;
					}
					return this;
				}
				this.pop = function() {
					--this.c.length;
					return this;
				}
				this.fill = function(index, a_node) { // inserts a_node at index in node.children and so also sets kid_idx of a_node to be index
					a_node.k = index;
					(this.c[index] = a_node).p = this;
				}
				this.t_ = function(t) {
					this.t = t;
					return this;
				}
				this.x = 0;
				this.y = 0;
				this.cp = 0;
				this.lastpos = new Array();
				this.firstpos = new Array();
				this.nullable = false;
			}
			function at(index) {
				if (r[index] === undefined)
					r[index] = new node(index);
				return r[index];
			}
			function init_tree() {
				r = new Array();
				stack = new Array();
				at(0).push(
					at(1).t_(-2).push(
						at(2).push(
							at(3))),
					at(4).t_(ln2rei.length - 1)).p = r[0];
				stack[0] = r[3];
				tor = 4;
			}
			function make_tree() {
				for (var i = 0; i < re_ia.length - 1; ++i) {
					var t = stack[stack.length - 1], p = t.p, pp = p.p, r1 = at(tor + 1), r2 = at(tor + 2), r3 = at(tor + 3), r4 = at(tor + 4);
					switch (re_ia[i]) {
						case -1: // *
							var ls = p.c[0]; // left-most sibling
							if (ls.t == -3) { // is an '.'
								var rc = ls.c[1];
								ls.fill(1, r1.t_(-1).push(rc));
							} else {
								p.fill(0, r1.t_(-1).push(ls));
							}
							tor += 1;
							break;
						case -2: // +
							p.pop();
							pp.push(t.push(r1));
							stack[stack.length - 1] = r1;
							tor += 1;
							break;
						case -3: // (
							t.t_(-2).push(r1.push(r2));
							if (p.c.length == 1) {
								p.push(r3);
								stack[stack.length - 1] = r3;
								tor += 3;
							} else {
								pp.pop();
								pp.push(r3.push(p, r4));
								stack[stack.length - 1] = r4;
								tor += 4;
							}
							stack[stack.length] = r2;
							break;
						case -4: // )
							p.pop();
							t.t = -4;
							--stack.length;
							break;
						default:
							for (var j = 0; j < ln2rei.length; ++j) if (ln2rei[j] == i) { t.t = j; break; }
							if (p.c.length == 1) {
								p.push(r1);
								stack[stack.length - 1] = r1;
								tor += 1;
							} else {
								pp.pop();
								pp.push(r1.push(p, r2));
								stack[stack.length - 1] = r2;
								tor += 2;
							}
					}
				}
				t = stack[stack.length - 1];
				t.p.pop();
				t.t = -4;
				var lc = r[0].c[0];
				if (lc.c.length == 1) {
					lc.t = -4;
					var lcc = lc.c[0];
					lcc.p = r[0];
					r[0].c[0] = lcc;
				}
			}
			function discard_unnecessary_nodes() {
				for (var i = 0; i <= tor; ++i) {
					var t = r[i];
					if (t.c.length == 1 && (t.t == -3 || t.t == -2)) { // . or + node
						t.t = -4;
						t.p.fill(t.k, t.c[0]);
					}
				}
			}
			function make_indexes_start_from_0() {
				var k = 0;
				for (var i = 0; i <= tor; i++)
					if (r[i].t != -4)
						(r[k] = r[i]).id = k++;
				r.length = k;
			}
			function calc_follovvpos() {
				for (var i = 0; i < r.length; ++i) r[i].cp = 0;
				stack = new Array();
				var cn = r[0];
				while (r[0].cp < r[0].c.length)
					if (cn.cp < cn.c.length)
						cn = cn.c[cn.cp];
					else {
						(cn = (n = stack[stack.length] = cn).p).cp++;
						var LC, RC;
						switch(n.t) {
							case -3:
								LC = n.c[0];
								RC = n.c[1];
								n.nullable = LC.nullable && RC.nullable;
								if (LC.nullable)
									n.firstpos = combo([LC.firstpos, RC.firstpos]);
								else
									n.firstpos = LC.firstpos;
								if (RC.nullable)
									n.lastpos = combo([LC.lastpos, RC.lastpos]);
								else
									n.lastpos = RC.lastpos;
								break;
							case -2:
								var fp = new Array();
								var lp = new Array();
								for (var j = 0; j < n.c.length; j++) {
									n.nullable = n.nullable || n.c[j].nullable;
									fp[fp.length] = n.c[j].firstpos;
									lp[lp.length] = n.c[j].lastpos;
								}
								n.firstpos = combo(fp);
								n.lastpos = combo(lp);
								break;
							case -1:
								LC = n.c[0];
								n.nullable = true;
								n.firstpos = LC.firstpos;
								n.lastpos = LC.lastpos;
								break;
							default:
								if (re_ia[ln2rei[n.t]] == -5)
									n.nullable = true;
								else {
									n.nullable = false;
									n.firstpos = n.lastpos = [n.t];
								}
						}
					}
				stack[stack.length] = n = r[0];
				LC = n.c[0];
				RC = n.c[1];
				n.nullable = LC.nullable && RC.nullable;
				if (LC.nullable)
					n.firstpos = combo([LC.firstpos, RC.firstpos]);
				else
					n.firstpos = LC.firstpos;
				if (RC.nullable)
					n.lastpos = combo([LC.lastpos, RC.lastpos]);
				else
					n.lastpos = RC.lastpos;
				follovvpos = new Array(ln2rei.length - 1);
				for (var i = 0; i < follovvpos.length; ++i) follovvpos[i] = new Array();
				for (var i = 0; i < stack.length; ++i) {
					var x = stack[i];
					switch(x.t) {
						case -3: // .^ cat-node
							var LC_s_lastpos = x.c[0].lastpos;
							for (var j = 0; j < LC_s_lastpos.length; ++j) {
								var y = LC_s_lastpos[j];
								follovvpos[y] = yog(follovvpos[y], x.c[1].firstpos);
							}
							break;
						case -1: // * star-node
							for (var j = 0; j < x.lastpos.length; ++j)
								follovvpos[x.lastpos[j]] = yog(follovvpos[x.lastpos[j]], x.firstpos);
					}
				}
			}
			function combo(array) {
				var a = new Array();
				for (var i = 0; i < array.length; ++i)
					for (var j = 0; j < array[i].length; ++j)
						a[a.length] = array[i][j];
				return a;
			}
			function yog() {
				var a = new Array();
				for (var i = 0; i < arguments.length; ++i)
					for (var j = 0; j < arguments[i].length; ++j) {
						var k = 0;
						for (; k < a.length; ++k)
							if (arguments[i][j] == a[k])
								break;
						if (k == a.length) {
							a[k] = arguments[i][j];
						}
					}
				sort(a);
				return a;
			}
			function state() {
				this.t = new Array();
				this.a = false;
				this.d = false;
				this.ida = new Array();
				this.x = 0;
				this.y = 0;
				this.tome = new Array();
				this.m = new Array();
				this.dont_calc = false;
			}
			function make_dfa() {
				pre = document.createElement( "pre" );
                pre.innerHTML += "<br/>make_dfa()<br/>---- ---";
                ana_div.appendChild( pre );
				s = new Array();
				(s[0] = new state()).ida = r[0].firstpos;
				var top = 0;
				while (top < s.length) {
					var cs = s[top];
					pre.innerHTML += "<br/>cs.ida=" + cs.ida;
					for (var i = 0; i < tokens.length; ++i) {
						var a1 = chhed(cs.ida, ti2lns[i]);
						var a2 = new Array();
						for (var j = 0; j < a1.length; ++j)
							for (var k = 0; k < follovvpos[a1[j]].length; ++k) {
								var l = 0;
								for (; l < a2.length; ++l)
									if (follovvpos[a1[j]][k] == a2[l])
										break;
								if (l == a2.length)
									a2[l] = follovvpos[a1[j]][k];
							}
						yog(a2);
						pre.innerHTML += "<br />&nbsp;&nbsp;" + cs.ida + " &cap; " + ti2lns[i] + " = " + a1 + "&nbsp;&nbsp;union_of_followposes=" + a2 + "&nbsp;<br />";
						var j = 0;
						for (; j < s.length; ++j) {
							if (are_same_arrays(a2, s[j].ida))
								break;
						}
						if (j == s.length) (s[j] = new state()).ida = a2;
						cs.t[i] = j;
						s[j].tome[s[j].tome.length] = [top, i];
						pre.innerHTML += "&nbsp;#" + j;
					}
					for (var i = 0; i < cs.ida.length; ++i)
						if (cs.ida[i] == ln2rei.length - 1)
							cs.a = true;
					if (!cs.a) {
						var i = 0;
						for (; i < tokens.length; ++i)
							if (cs.t[i] != top)
								break;
						if (i == cs.t.length)
							cs.d = true;
					}
					top++;
				}
				for (var i = 0; i < s.length; ++i)
					pre.innerHTML += "<br />" + i + " :" + s[i].t;
			}
			function chhed(a1, a2) {
				var a = new Array();
				for (var i = 0; i < a1.length; ++i)
					for (var j = 0; j < a2.length; ++j)
						if (a1[i] == a2[j])
							a[a.length] = a1[i];
				sort(a);
				return a;
			}
			function are_same_arrays(a1, a2) {
				if (a1.length != a2.length) return false;
				for (var i = 0; i < a1.length; ++i) if (a1[i] != a2[i]) return false;
				return true;
			}
			function sort(a) {
				var count = 0;
				for (var i = 0; i < a.length - 1; ++i)
					for (var j = 0; j < a.length - 1 - i; ++j)
						if (a[j] > a[j + 1]) {
							var temp = a[j];
							a[j] = a[j + 1];
							a[j + 1] = temp;
						}
			}
			function min_dfa() {
				var t = new Array(s.length);
				for (var i = 0; i < t.length; ++i) t[i] = new Array(s.length);
				for (var i = 0; i < t.length; ++i)
					t[i][i] = false;
				unmarkeds = new Array();
				for (var i = 0; i < t.length - 1; ++i)
					for (var j = i + 1; j < t.length; ++j)
						if (!( t[i][j] = t[j][i] = s[i].a ? (s[j].a ? false : true) : (s[j].a ? true : false) ))
							unmarkeds[unmarkeds.length] = [i, j];
				var pl;
				do {
					pl = unmarkeds.length;
					for (var i = 0; i < unmarkeds.length; ++i) {
						var x = unmarkeds[i][0];
						var y = unmarkeds[i][1];
						for (var j = 0; !t[x][y] && j < tokens.length; ++j) {
							t[y][x] = t[x][y] = t[ s[x].t[j] ][ s[y].t[j] ];
						}
						if (t[x][y]) {
							unmarkeds[i] = unmarkeds[unmarkeds.length - 1];
							--unmarkeds.length;
							--i;
						}
					}
				} while (unmarkeds.length != pl);
				for (var i = 0; i < unmarkeds.length; ++i) {
					var unm0 = unmarkeds[i][0];
					var unm1 = unmarkeds[i][1];
					var s0 = s[unm0];
					var s1 = s[unm1];
					s0.m[s0.m.length] = s1.m[s1.m.length] = unm0;
					s0.m[s0.m.length] = s1.m[s1.m.length] = unm1;
				}
				var s2 = new Array();
				for (var i = 0; i < s.length; ++i) {
					var cs = s[i];
					var csm = cs.m;
					if (csm.length == 0) {
						var tome = cs.tome;
						for (var k = 0; k < tome.length; ++k)
							s[tome[k][0]].t[tome[k][1]] = s2.length;
						s2[s2.length] = s[i];
					} else if (!cs.dont_calc) {
						csm = yog(csm);
						for (var j = 0; j < csm.length; ++j) {
							var cs2 = s[csm[j]];
							cs2.dont_calc = true;
							var tome = cs2.tome;
							for (var k = 0; k < tome.length; ++k)
								s[tome[k][0]].t[tome[k][1]] = s2.length;
						}
						s2[s2.length] = s[i];
					}
				}
				s = s2;
			}
			function min_dfa_new() {
				var t = new Array(s.length);
				for (var i = 0; i < t.length; ++i) t[i] = new Array(s.length);
                var pi = 0; // pass_index
				for (var i = 0; i < t.length; ++i)
                    for (var j = 0; j < t.length; ++j)
                        t[i][j] = i == j ? pi : -1;
                pi++;
				unmarkeds = new Array();
				for (var i = 0; i < t.length - 1; ++i)
					for (var j = i + 1; j < t.length; ++j)
						if (!( t[i][j] = t[j][i] = s[i].a ? (s[j].a ? -1 : 1) : (s[j].a ? 1 : -1) ))
							unmarkeds[unmarkeds.length] = [i, j];
				var pl;
				do {
                    pi++;
					pl = unmarkeds.length;
					for (var i = 0; i < unmarkeds.length; ++i) {
						var x = unmarkeds[i][0];
						var y = unmarkeds[i][1];
						for (var j = 0; t[x][y] == -1 && j < tokens.length; ++j) {
							t[y][x] = t[x][y] = t[ s[x].t[j] ][ s[y].t[j] ] ? pi : -1;
						}
						if (t[x][y] != -1) {
							unmarkeds[i] = unmarkeds[unmarkeds.length - 1];
							--unmarkeds.length;
							--i;
						}
					}
				} while (unmarkeds.length != pl);
                print_dfa_min_table( t );
				for (var i = 0; i < unmarkeds.length; ++i) {
					var unm0 = unmarkeds[i][0];
					var unm1 = unmarkeds[i][1];
					var s0 = s[unm0];
					var s1 = s[unm1];
					s0.m[s0.m.length] = s1.m[s1.m.length] = unm0;
					s0.m[s0.m.length] = s1.m[s1.m.length] = unm1;
				}
				var s2 = new Array();
				for (var i = 0; i < s.length; ++i) {
					var cs = s[i];
					var csm = cs.m;
					if (csm.length == 0) {
						var tome = cs.tome;
						for (var k = 0; k < tome.length; ++k)
							s[tome[k][0]].t[tome[k][1]] = s2.length;
						s2[s2.length] = s[i];
					} else if (!cs.dont_calc) {
						csm = yog(csm);
						for (var j = 0; j < csm.length; ++j) {
							var cs2 = s[csm[j]];
							cs2.dont_calc = true;
							var tome = cs2.tome;
							for (var k = 0; k < tome.length; ++k)
								s[tome[k][0]].t[tome[k][1]] = s2.length;
						}
						s2[s2.length] = s[i];
					}
				}
				s = s2;
			}
            function print_dfa_min_table( t ) {
                var state_name_len_max = 0;
                for( var i = 0; i < s.length; i++ )
                {
                    if( state_name_len_max < s[ i ].ida.length )
                        state_name_len_max = s[ i ].ida.length;
                }
                const W = 1 + ( 2 * state_name_len_max - 1 ) + 1; // left space + hyphened-poses + right space
                const NL = '\n';
                const S = function( str ) { return spacify( W, str ); };

                pre.innerHTML += NL + NL + NL;
                pre.innerHTML += 'states' + NL;
                pre.innerHTML += '------' + NL;

                pre.innerHTML += NL + S( 'state.ida' ) + S( 'index' );
                for( var i = 0; i < tokens.length; i++ )
                    pre.innerHTML += S( tokens[ i ] );

                pre.innerHTML += NL + S( '----- ---' ) + S( '-----' );
                for( var i = 0; i < tokens.length; i++ )
                    pre.innerHTML += S( repeat( '-', tokens[ i ].length ) );

                for( var i = 0; i < s.length; i++ )
                {
                    pre.innerHTML += NL + NL + S( s[ i ].ida.join( '.' ) ) + S( i );
                    for( var j = 0; j < tokens.length; j++ )
                        pre.innerHTML += S( s[ i ].t[ j ] );
                }

                pre.innerHTML += NL + NL + NL;
                pre.innerHTML += 'dfa_min_table' + NL;
                pre.innerHTML += '--- --- -----' + NL;

				for (var i = 0; i < t.length; ++i)
                {
                    pre.innerHTML += NL + NL + S( i );
					for (var j = 0; j < t.length; ++j)
                    {
                        pre.innerHTML += S( t[ j ][ i ] );
                    }
                }
                pre.innerHTML += NL + NL + S( '' );
                for( var i = 0; i < s.length; i++ )
                    pre.innerHTML += S( i );
            }
			function dravv_dfa() {
				var font_size = 27;
				var font_ = font_size + "px Arial Unicode MS";
				var edge_color = "CornflowerBlue";
				var edge_vv = 1;
				var seperator_color = "CornflowerBlue";
				var seperator_vv = 2;
				var seperator_margin = 2;
				var inter_token_distance = (2 * seperator_margin) + seperator_vv;
				var token_color = "black";
				var dead_state_color = "black";
				var normal_state_color = "#201291";
				var acc_state_color = "green";
				var state_label_color = "white";
				var arrovv_head_color = "skyBlue";

				CV_dfa = document.createElement("canVas");
				ref_kid = insertAfter( ref_kid, CV_dfa );
				ref_kid = insertAfter( ref_kid, document.createElement("br") );
				var clone_of_regex;
				if (la2flag) {
					la2flag = false;
					clone_of_regex = regex.cloneNode(true);
					clone_of_regex.removeAttribute("id");
					clone_of_regex.innerHTML += tf.value;
				} else {
					clone_of_regex = document.createElement("diV");
					var strg = "";
					for (var i = 0; i < re_ia.length - 1; ++i) {
						var novv = re_ia[i];
						switch (novv) {
						case -1:
							strg += "<span>*</span>";
							break;
						case -2:
							strg += "<span>+</span>";
							break;
						case -3:
							strg += "<span>(</span>";
							break;
						case -4:
							strg += "<span>)</span>";
							break;
						case -5:
							strg += "<span>ε</span>";
							break;
						default:
							strg += tokens[novv];
						}
					}
					clone_of_regex.innerHTML = strg;
				}
				ref_kid = insertAfter( ref_kid, clone_of_regex );
				var c = CV_dfa.getContext("2d");

				var longest_string = tokens[0];
				for (var i = 1; i < tokens.length; ++i) longest_string += tokens[i];
				c.font = font_;
				var sr = 20 + c.measureText(s.length - 1).width + 7;
				c.font = font_;
				inter_state_distance = sr + (c.measureText(longest_string).width + (tokens.length - 1) * inter_token_distance);
				const_x_incr = (2 * sr) + inter_state_distance;

				CV_dfa.width = s.length * const_x_incr;
				max_aboVe = max_belovv = 1;
				for (var i = 0; i < s.length; ++i) {
					for (var j = 0; j < tokens.length; ++j) {
						var difference = s[i].t[j] - i;
						if (difference < 0) {
							difference *= -1;
							if (max_belovv < difference)
								max_belovv = difference;
						} else
							if (max_aboVe < difference)
								max_aboVe = difference;
					}
				}
				CV_dfa.height = (max_aboVe + max_belovv) * const_x_incr / 2 + 2 * font_size;

				s[0].x = sr;
				s[0].y = max_aboVe * const_x_incr / 2 + font_size;

				for (var i = 1; i < s.length; ++i) {
					s[i].y = s[i - 1].y;
					s[i].x = s[i - 1].x + const_x_incr;
				}
				for (var i = 0; i < s.length; ++i) {
					var a1 = new Array();
					for (var j = 0; j < tokens.length; ++j) {
						var index = -1;
						for (var k = 0; k < a1.length; ++k) if (a1[k][0] == s[i].t[j]) { index = k; break; }
						if (index === -1) a1[a1.length] = [ s[i].t[j], j ]; else a1[index][ a1[index].length ] = j;
					}
					for (var j = 0; j < a1.length; ++j) {
						if (hideDead && s[a1[j][0]].d) continue;
						var label = tokens[ a1[j][1] ];
						var label_vv = 0;
						for (var k = 2; k < a1[j].length; ++k) {
							label += tokens[ a1[j][k] ];
							label_vv += inter_token_distance;
						}
						c.font = font_;
						label_vv += c.measureText(label).width;
						var x_pos;
						var y_pos;
						var center_x_yam = ( s[i].x + s[ a1[j][0] ].x ) / 2;
						var radius = s[i].x - s[ a1[j][0] ].x;
						radius /= (radius < 0 ? -1 : 1) * 2;
						if (i < a1[j][0]) {
							c.beginPath();
							c.arc(center_x_yam, s[i].y, radius, 0, Math.PI, true);
							c.lineWidth = edge_vv;
							c.strokeStyle = edge_color;
							c.stroke();
							c.beginPath();
							c.arc(center_x_yam, s[i].y, radius, 0, (Math.PI * 2) - (2 * 20 * Math.PI / 180), true);
							c.lineWidth = 7;
							c.strokeStyle = arrovv_head_color;
							c.lineCap = "round";
							c.stroke();
							x_pos = center_x_yam - label_vv / 2;
							y_pos = s[i].y - radius;
						} else if (i > a1[j][0]) {
							c.lineWidth = edge_vv;
							c.beginPath();
							c.strokeStyle = edge_color;
							c.arc(center_x_yam, s[i].y, radius, 0, Math.PI, false);
							c.stroke();
							c.strokeStyle = arrovv_head_color;
							c.lineWidth = 7;
							c.beginPath();
							c.arc(center_x_yam, s[i].y, radius, Math.PI, (Math.PI) - (2 * 20 * Math.PI / 180), true);
							c.lineCap = "round";
							c.stroke();
							x_pos = center_x_yam - label_vv / 2;
							y_pos = s[i].y + radius;
						} else {
							c.beginPath();
							c.lineWidth = edge_vv;
							c.strokeStyle = edge_color;
							c.arc(s[i].x + sr, s[i].y, sr, -( (2 * Math.PI / 3) + (Math.PI / 180) ), Math.PI / 2, false);
							c.stroke();
							c.lineWidth = 7;
							c.beginPath();
							c.strokeStyle = arrovv_head_color;
							c.arc(s[i].x + sr, s[i].y, sr, ( (2 * Math.PI / 3) + (Math.PI / 180) ), Math.PI / 2, true);
							c.lineCap = "round";
							c.stroke();
							x_pos = s[i].x + (2 * sr) - 4;
							y_pos = s[i].y;
						}
						c.lineCap = "butt";
						c.lineWidth = 1;
						c.textAlign = "left";
						c.textBaseline = "middle";
						c.font = font_;
						c.strokeStyle = "white";
						c.strokeText(tokens[ a1[j][1] ], x_pos, y_pos);
						c.fillStyle = token_color;
						c.fillText(tokens[ a1[j][1] ], x_pos, y_pos);
						for (var k = 2; k < a1[j].length; ++k) {
							x_pos += c.measureText(tokens[ a1[j][k - 1] ]).width + inter_token_distance;
							c.lineWidth = 1;
							c.strokeStyle = "white";
							c.font = font_;
							c.strokeText(tokens[ a1[j][k] ], x_pos, y_pos);
							c.fillStyle = token_color;
							c.font = font_;
							c.fillText(tokens[ a1[j][k] ], x_pos, y_pos);
							c.beginPath();
							c.moveTo(x_pos - inter_token_distance / 2, y_pos - font_size);
							c.lineWidth = seperator_vv;
							c.lineTo(x_pos - inter_token_distance / 2, y_pos + font_size);
							c.strokeStyle = seperator_color;
							c.stroke();
						}
					}
				}
				for (var i = 0; i < s.length; ++i) {
					if (hideDead && s[i].d) continue;
					c.beginPath();
					if (s[i].d) c.fillStyle = dead_state_color;
					else if (s[i].a) c.fillStyle = acc_state_color;
					else c.fillStyle = normal_state_color;
					c.arc(s[i].x, s[i].y, sr, 0, Math.PI * 2, true);
					c.closePath();
					c.fill();
					c.lineWidth = 1;
					c.textAlign = "center";
					c.textBaseline = "middle";
					c.strokeStyle = state_label_color;
					c.font = font_;
					c.strokeText(i, s[i].x, s[i].y);
					c.fillStyle = state_label_color;
					c.font = font_;
					c.fillText(i, s[i].x, s[i].y);
				}
			}
			function la1() {
				var re_s = tf.value;
				if (re_s.length == 0) { accNothing(); return; }
				for (var i = 0; i < re_s.length; ++i) {
					var cc = re_s.charAt(i);
					var j;
					switch (cc) {
						case '\\':
							cc = re_s.charAt(++i);
							for (j = 0; j < tokens.length; ++j) if (tokens[j] == cc) break;
							if (j == tokens.length) tokens[j] = "" + cc;
							if (ti2lns[j] === undefined) ti2lns[j] = new Array();
							ti2lns[j][ti2lns[j].length] = ln2rei.length;
							ln2rei[ln2rei.length] = re_ia.length;
							re_ia[re_ia.length] = j;
							break;
						case '*':
							re_ia[re_ia.length] = -1;
							break;
						case '+':
							re_ia[re_ia.length] = -2;
							break;
						case '(':
							re_ia[re_ia.length] = -3;
							break;
						case ')':
							re_ia[re_ia.length] = -4;
							break;
						case '.': // null
							ln2rei[ln2rei.length] = re_ia.length;
							re_ia[re_ia.length] = -5;
							break;
						default:
							for (j = 0; j < tokens.length; ++j) if (tokens[j] == cc) break;
							if (j == tokens.length) tokens[j] = "" + cc;
							if (ti2lns[j] === undefined) ti2lns[j] = new Array();
							ti2lns[j][ti2lns[j].length] = ln2rei.length;
							ln2rei[ln2rei.length] = re_ia.length;
							re_ia[re_ia.length] = j;
					}
				}
				ln2rei[ln2rei.length] = re_ia.length;
				re_ia[re_ia.length] = -6;

				info( 're_ia' );
				info( 'tokens' );
				info( 'ti2lns' );
				info( 'ln2rei' );

				show_lex_ana(  );
				init_tree();
				make_tree();
				discard_unnecessary_nodes();
				make_indexes_start_from_0();
				draw_tree();
				calc_follovvpos();
				make_dfa();
				min_dfa();
                swap_dead_and_last();
				dravv_dfa();
			}
            function swap_dead_and_last() {

            }
			function accNothing() {
				var circle = document.createElement("diV");
				circle.setAttribute("style", "height: 72pt; width: 72pt; background-color: #201291; border-radius: 36pt; margin: 20pt 0pt; font-size: 27pt; font-weight: 700; text-align: center; color: white; line-height: 72pt;");
				circle.innerHTML = "0";

				var anHr = document.createElement("diV");
				anHr.setAttribute("class", "anHr");
				output.insertBefore(anHr, ref_kid);
				output.insertBefore(circle, ref_kid);
				output.insertBefore(document.createElement("br"), ref_kid);
				var clone_of_regex = document.createElement("diV");
				clone_of_regex.setAttribute("style", "color: red; font-size: 20px; letter-spacing: 1px;");
				clone_of_regex.innerHTML = "Accepts Nothing";
				output.insertBefore(clone_of_regex, ref_kid);
				ref_kid = anHr;
			}
        </script>
        <script>
            function empty_id_attr() {
                for (var i = 0; i < arguments.length; ++i) {
                    try {
                        if ( typeof arguments[i] === 'string' )
                            document.getElementById( arguments[i] ).removeAttribute( "id" );
                        else
                            arguments[i].removeAttribute( "id" );
                    } catch ( err ) {
                        // console.log( err );
                    }
                }
            }
            function insertAfter(referenceNode, newNode) {
                // https://stackoverflow.com/a/4793630
                referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
                return newNode;
            }
            function insertBefore(referenceNode, newNode) {
                referenceNode.parentNode.insertBefore(newNode, referenceNode );
                return newNode;
            }
			function show_lex_ana() {

				var anHr = document.createElement("diV");
				anHr.setAttribute("class", "anHr");
				ref_kid = insertAfter( regex, anHr );

				ana_div = document.createElement( "div" ); // keep this one global
				ref_kid = insertAfter( ref_kid, ana_div );
				ana_div.setAttribute( "class", "analysis" );

				ana_div.appendChild( document.createElement( "br" ) );

				var lex_ana = document.createElement( "div" );
				ana_div.appendChild( lex_ana );
				lex_ana.setAttribute( "style", "border: 0px solid black;" );

                empty_id_attr( 'table1', 'table2' ); // remove previous id's given in following table creation ..

				lex_ana.innerHTML = "<table id='table1'><tr><th>ln</th></tr><tr><th>re_s</th></tr><tr><th>re_ia</th></tr><tr><th>rei</th></tr></table><br /><table id='table2'><tr><th>ti</th><th>token</th><th>lns</th></tr></table>";
				for (var i = 0, j = 0; i < re_ia.length; ++i) {
					var c = re_ia[i];
					table1.rows[2].insertCell(-1).innerHTML = c;
					var ln = table1.rows[0].insertCell(-1);
					switch(c) {
						case -1: table1.rows[1].insertCell(-1).innerHTML = "<span>\u2734</span>"; break;
						case -2: table1.rows[1].insertCell(-1).innerHTML = "<span>\u271a</span>"; break;
						case -3: table1.rows[1].insertCell(-1).innerHTML = "<span>(</span>"; break;
						case -4: table1.rows[1].insertCell(-1).innerHTML = "<span>)</span>"; break;
						case -5: table1.rows[1].insertCell(-1).innerHTML = "<span>NULL</span>"; ln.innerHTML = j++; break;
						case -6: table1.rows[1].insertCell(-1).innerHTML = "<span>EoRE</span>"; ln.innerHTML = j++; break;
						default: table1.rows[1].insertCell(-1).innerHTML = tokens[c]; ln.innerHTML = j++;
					}
					table1.rows[3].insertCell(-1).innerHTML = i;
				}

				for (var i = 0; i < ti2lns.length; ++i) {
					var a_row = table2.insertRow(-1);
					a_row.insertCell(-1).innerHTML = i;
					a_row.insertCell(-1).innerHTML = tokens[i];
					var a_cell_lns = a_row.insertCell(-1);
					a_cell_lns.innerHTML = ti2lns[i][0];
					for (var j = 1; j < ti2lns[i].length; ++j) a_cell_lns.innerHTML += ", " + ti2lns[i][j];
				}
				var a_row = table2.insertRow(-1);
				var a_cell = a_row.insertCell(-1);
				a_cell.setAttribute("colspan", "2");
				a_cell.style.backgroundColor = "yellow";
				a_cell.innerHTML = "NULL";
				a_cell = a_row.insertCell(-1);
				if (nulls.length > 0) a_cell.innerHTML = nulls[0];
				for (var j = 1; j < nulls.length; ++j) a_cell.innerHTML += ", " + nulls[j];
			}
			function draw_tree() {

				var CV_tree = document.createElement( "canvas" );
				ana_div.appendChild( CV_tree );
				CV_tree.setAttribute( "style", "border: 0px solid black;" );

				var min_internode_distance = 20 + 12;
				var font_size = 27;
				var font_ = font_size + "px Arial Unicode MS";

				var c = CV_tree.getContext("2d");
				//calc longest label's length

				var longest_label = "NULL";
				for (var i = 0; i < tokens.length; ++i)
					if (longest_label.length < tokens[i].length)
						longest_label = tokens[i];
				c.font = font_;
				internode_distance = min_internode_distance + c.measureText(longest_label).width;

				cn = r[0];
				cn.x = cn.y = internode_distance;
				VH = 2 * internode_distance; //Vertical height
				while (r[0].cp < r[0].c.length) {
					if (cn.cp < cn.c.length) {
						if (cn.cp == 0) {
							cn = cn.c[cn.cp];
							cn.x = cn.p.x;
							cn.y = cn.p.y + internode_distance;
							if (cn.y == VH) VH += internode_distance;
							last_left = cn.x;
						} else {
							cn = cn.c[cn.cp];
							cn.x = last_left += internode_distance;
							cn.y = cn.p.y + internode_distance;
						}
					} else {
						(cn = cn.p).cp++;
						if (cn.c.length > 0)
							cn.x = (cn.c[0].x + cn.c[cn.c.length - 1].x) / 2;
					}
				}
				cn = r[0];
				if (cn.c.length > 0)
					cn.x = (cn.c[0].x + cn.c[cn.c.length - 1].x) / 2;

				CV_tree.height = VH;
				CV_tree.width = r[0].c[1].x + internode_distance;

				c.lineStyle = "black";
				c.lineWidth = 2;
				for (i = 0; i < r.length; ++i) {
					for (var j = 0; j < r[i].c.length; ++j) {
						c.beginPath();
						c.moveTo(r[i].x, r[i].y);
						c.lineTo(r[i].c[j].x, r[i].c[j].y);
						c.stroke();
					}
				}

				c.lineWidth = 1;
				c.font = font_;
				c.textAlign = "center";
				c.textBaseline = "middle";
				for (i = 0; i < r.length; ++i) {

					var a_node = r[i];
					var x      = a_node.x;
					var y      = a_node.y;
					var type   = a_node.t;

					c.beginPath();
					c.arc(x, y, font_size / 2, 0, 2 * Math.PI, true);
					c.strokeStyle = c.fillStyle = "white";
					c.stroke();
					c.fill();
					c.fillStyle = "red"; //special cases are painted in red .. tokens in black

					switch(type) {
						case -3: //concat/dot
							c.strokeText("\u2022", x, y);
							c.fillText("\u2022", x, y);
							break;
						case -1: //*
							c.strokeText("\u2734", x, y);
							c.fillText("\u2734", x, y);
							break;
						case -2: //+
							c.strokeText("\u271a", x, y);
							c.fillText("\u271a", x, y);
							break;
						case -4: //DISCARDED
							c.strokeText("\u2620", x, y);
							c.fillText("\u2620", x, y);
							break;
						default:
							if (re_ia[ln2rei[type]] == -5) {
								c.strokeText("NULL", x, y);
								c.fillText("NULL", x, y);
							} else if (type + 1 == ln2rei.length) {
								c.strokeText("EoRE", x, y);
								c.fillText("EoRE", x, y);
							} else {
								c.fillStyle = "black"; //set black
								c.strokeText(tokens[re_ia[ln2rei[type]]], x, y);
								c.fillText(tokens[re_ia[ln2rei[type]]], x, y);
								c.fillStyle = "red"; //set red back
							}
					}
				}
			}
        </script>
        <script>
            function repeat( str, count = 1 ) {
                var temp = '' + str;
                for( var k = 1; k < count; k++ )
                    temp += str;
                return temp;
            }
            function spacify( width, str, alignment = 'RIGHT', space = ' ' ) {
                str = '' + str;
                var spaces = '';
                switch( alignment.toUpperCase(  ) )
                {
                    case 'LEFT':
                        for( var i = str.length - 1; i < width; i++ )
                            spaces += space;
                        return str + spaces;
                    case 'MIDDLE':
                        for( var i = str.length - 1; i < width >> 1; i++ )
                            spaces += space;
                        return spaces + str + spaces + ( width & 1 === 1 ? space : '' );
                    default:
                    case 'RIGHT':
                        for( var i = str.length - 1; i < width; i++ )
                            spaces += space;
                        return spaces + str;
                }
            }
            function info( obj_name, idx_arr = true ) {
                try {
                    if( idx_arr && eval( obj_name ) instanceof Array )
                        console.log(
                            obj_name,
                            JSON.stringify(
                                eval( obj_name ).reduce(
                                    function( dict, ele )
                                    {
                                        dict[ Object.keys( dict ).length ] = ele;
                                        return dict;
                                    },
                                    {  } // this is passed as dict arg to above func and arr's ele's are passed as ele arg
                                ),
                                null,
                                2
                            )
                        );
                    else
                        console.log( obj_name, JSON.stringify( eval( obj_name ), null, 2 ) );
                } catch( e ) {
                    console.log( JSON.stringify( obj_name, null, 2 ) );
                }
            }
            function paint_mdfa( regex ) {
                if( !window_loaded ) {
                    console.log( 'the paiter ins\'t ready yet!' );
                    return;
                }
                tf.value = regex;
                tf.onkeyup( event = { keyCode : 13 } );
                tf.onkeyup( event = { keyCode : 20 + 7 } );
            }
            var window_loaded = false;
            window.onload = function(  ) {
                window_loaded = true;
                // paint_mdfa( 'a+b*(a+b)' );
                paint_mdfa( 'a+b*c(a+b+c)+c' );
            };
        </script>
	</body>
</html>
